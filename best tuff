-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")

-- Global state for persistent values
_G.CustomKeyState = _G.CustomKeyState or {
    desiredWalk = LocalPlayer:GetAttribute("NTD_WalkSpeed") or 16,
    desiredJump = LocalPlayer:GetAttribute("NTD_JumpPower") or 50
}

-- Remove previous GUI
for _, gui in pairs(LocalPlayer:WaitForChild("PlayerGui"):GetChildren()) do
    if gui.Name == "CustomKeyGUI" then gui:Destroy() end
end

-- ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CustomKeyGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = LocalPlayer.PlayerGui

-- Global toggle (off-GUI) - circular button in separate ScreenGui so it remains independent
local globalToggleGui = Instance.new("ScreenGui")
globalToggleGui.Name = "GlobalToggleGUI"
globalToggleGui.ResetOnSpawn = false
globalToggleGui.Parent = LocalPlayer.PlayerGui

local toggleBtn = Instance.new("TextButton", globalToggleGui)
toggleBtn.Name = "ToggleButton"
toggleBtn.Size = UDim2.new(0,56,0,56)
toggleBtn.Position = UDim2.new(1,-72,1,-140) -- bottom-right, slightly above typical nav
toggleBtn.AnchorPoint = Vector2.new(0,0)
toggleBtn.BackgroundColor3 = Color3.fromRGB(40,40,45)
toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
toggleBtn.Text = "GUI"
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 14
toggleBtn.AutoButtonColor = true
Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(1,0)
local arc = Instance.new("UIAspectRatioConstraint", toggleBtn)
arc.AspectRatio = 1

-- keep toggle visible even when main GUI disabled; clicking toggles main ScreenGui Enabled
toggleBtn.MouseButton1Click:Connect(function()
    -- toggle the main GUI enabled state
    local main = LocalPlayer.PlayerGui:FindFirstChild("CustomKeyGUI")
    if main then
        main.Enabled = not main.Enabled
        toggleBtn.BackgroundColor3 = main.Enabled and Color3.fromRGB(40,110,80) or Color3.fromRGB(40,40,45)
    else
        -- if the main GUI doesn't exist (was destroyed), attempt to run unlock flow again if allowed
        -- simplest approach: recreate the initial ScreenGui by firing the submit handler if key is correct
        local existing = LocalPlayer.PlayerGui:FindFirstChild("CustomKeyGUI")
        if existing then
            existing.Enabled = true
            toggleBtn.BackgroundColor3 = Color3.fromRGB(40,110,80)
        else
            -- cannot recreate full GUI safely here; just show feedback
            -- If user unlocked previously, they can re-run the script to recreate GUI
            feedback.Text = "GUI missing; re-run script to create."
        end
    end
end)


-- Overlay
local overlay = Instance.new("Frame", screenGui)
overlay.Size = UDim2.new(1,0,1,0)
overlay.BackgroundColor3 = Color3.fromRGB(0,0,0)
overlay.BackgroundTransparency = 0.5

-- Modal frame
local modal = Instance.new("Frame", screenGui)
modal.Size = UDim2.new(0,420,0,200)
modal.Position = UDim2.new(0.5,0,0.5,0)
modal.AnchorPoint = Vector2.new(0.5,0.5)
modal.BackgroundColor3 = Color3.fromRGB(30,30,30)
Instance.new("UICorner", modal)

-- Title & description
local title = Instance.new("TextLabel", modal)
title.Size = UDim2.new(1,-24,0,30)
title.Position = UDim2.new(0,12,0,12)
title.BackgroundTransparency = 1
title.Text = "Enter Access Key"
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextColor3 = Color3.fromRGB(240,240,240)
title.TextXAlignment = Enum.TextXAlignment.Left

local desc = Instance.new("TextLabel", modal)
desc.Size = UDim2.new(1,-24,0,44)
desc.Position = UDim2.new(0,12,0,44)
desc.BackgroundTransparency = 1
desc.Text = "Paste the key from Discord to unlock the GUI."
desc.Font = Enum.Font.Gotham
desc.TextSize = 14
desc.TextColor3 = Color3.fromRGB(200,200,200)
desc.TextWrapped = true

-- Input box
local inputBox = Instance.new("TextBox", modal)
inputBox.Size = UDim2.new(1,-120,0,32)
inputBox.Position = UDim2.new(0,12,0,100)
inputBox.BackgroundColor3 = Color3.fromRGB(50,50,50)
inputBox.TextColor3 = Color3.fromRGB(255,255,255)
inputBox.ClearTextOnFocus = false
Instance.new("UICorner", inputBox)

-- Submit button
local submit = Instance.new("TextButton", modal)
submit.Size = UDim2.new(0,88,0,32)
submit.Position = UDim2.new(1,-100,0,100)
submit.BackgroundColor3 = Color3.fromRGB(70,130,240)
submit.TextColor3 = Color3.fromRGB(255,255,255)
submit.Text = "Submit"
Instance.new("UICorner", submit)

-- Copy Discord button
local copyBtn = Instance.new("TextButton", modal)
copyBtn.Size = UDim2.new(0,120,0,28)
copyBtn.Position = UDim2.new(0.5,-60,1,-36)
copyBtn.BackgroundColor3 = Color3.fromRGB(100,150,255)
copyBtn.TextColor3 = Color3.fromRGB(255,255,255)
copyBtn.Text = "Copy Discord Link"
Instance.new("UICorner", copyBtn)

-- Feedback
local feedback = Instance.new("TextLabel", modal)
feedback.Size = UDim2.new(1,-24,0,20)
feedback.Position = UDim2.new(0,12,1,-64)
feedback.BackgroundTransparency = 1
feedback.Text = ""
feedback.Font = Enum.Font.Gotham
feedback.TextSize = 14
feedback.TextColor3 = Color3.fromRGB(255,180,180)

-- Allowed key
local ALLOWED_KEYS = {"GDIRSWTG5562HF234GDHDFTD46TFYTRDF45C"}

-- Tween helper
local function tween(inst, props, time, style, dir)
    local ti = TweenInfo.new(time or 0.25, style or Enum.EasingStyle.Quad, dir or Enum.EasingDirection.Out)
    local t = TweenService:Create(inst, ti, props)
    t:Play()
    return t
end

-- store connections for cleanup
local connections = {}

-- Unlock function
local function unlock()
    feedback.Text = "Key accepted! Unlocking GUI..."
    tween(modal, {Position = modal.Position + UDim2.new(0,0,0,40), BackgroundTransparency=1}, 0.25)
    tween(overlay, {BackgroundTransparency=1},0.25)
    wait(0.25)
    modal:Destroy()
    overlay:Destroy()

    -- Main window
    local window = Instance.new("Frame", screenGui)
    window.Name = "MainWindow"
    window.Size = UDim2.new(0,600,0,400)
    window.Position = UDim2.new(0.5,0,0.5,0)
    window.AnchorPoint = Vector2.new(0.5,0.5)
    window.BackgroundColor3 = Color3.fromRGB(28,28,30)
    Instance.new("UICorner", window)

    -- Header (drag)
    local header = Instance.new("Frame", window)
    header.Size = UDim2.new(1,0,0,40)
    header.BackgroundColor3 = Color3.fromRGB(20,20,20)
    Instance.new("UICorner", header)

    local headerTitle = Instance.new("TextLabel", header)
    headerTitle.Size = UDim2.new(1,-16,1,0)
    headerTitle.Position = UDim2.new(0,8,0,0)
    headerTitle.BackgroundTransparency = 1
    headerTitle.Text = "Lucky Blocks Utility"
    headerTitle.Font = Enum.Font.GothamBold
    headerTitle.TextSize = 18
    headerTitle.TextColor3 = Color3.fromRGB(240,240,240)
    headerTitle.TextXAlignment = Enum.TextXAlignment.Left

    -- Minimize and Close buttons
    local btnClose = Instance.new("TextButton", header)
    btnClose.Size = UDim2.new(0,32,0,24)
    btnClose.Position = UDim2.new(1,-40,0,8)
    btnClose.AnchorPoint = Vector2.new(0,0)
    btnClose.BackgroundColor3 = Color3.fromRGB(140,40,40)
    btnClose.TextColor3 = Color3.fromRGB(255,255,255)
    btnClose.Text = "x"
    btnClose.Font = Enum.Font.GothamBold
    btnClose.TextSize = 16
    btnClose.AutoButtonColor = true
    Instance.new("UICorner", btnClose)

    local btnMin = Instance.new("TextButton", header)
    btnMin.Size = UDim2.new(0,32,0,24)
    btnMin.Position = UDim2.new(1,-80,0,8)
    btnMin.AnchorPoint = Vector2.new(0,0)
    btnMin.BackgroundColor3 = Color3.fromRGB(120,120,120)
    btnMin.TextColor3 = Color3.fromRGB(255,255,255)
    btnMin.Text = "-"
    btnMin.Font = Enum.Font.GothamBold
    btnMin.TextSize = 18
    btnMin.AutoButtonColor = true
    Instance.new("UICorner", btnMin)

    -- Minimize toggles content visibility (left + content frames)
    local minimized = false
    btnMin.MouseButton1Click:Connect(function()
        minimized = not minimized
        left.Visible = not minimized
        content.Visible = not minimized
        -- shrink window to header when minimized
        if minimized then
            window.Size = UDim2.new(0,300,0,40)
        else
            window.Size = UDim2.new(0,600,0,400)
        end
    end)

    -- Close hides main ScreenGui but leaves GlobalToggleGUI so it can be reopened
    btnClose.MouseButton1Click:Connect(function()
        if screenGui and screenGui.Parent then
            screenGui.Enabled = false
            -- update global toggle visual
            local main = LocalPlayer.PlayerGui:FindFirstChild("CustomKeyGUI")
            if main then
                local g = LocalPlayer.PlayerGui:FindFirstChild("GlobalToggleGUI")
                if g and g:FindFirstChild("ToggleButton") then
                    g.ToggleButton.BackgroundColor3 = Color3.fromRGB(40,40,45)
                end
            end
        end
    end)

    -- expose some UI roots for external access if desired
    _G.CustomKeyUI = {screenGui = screenGui, window = window, left = left, content = content, header = header}

    -- Tabs
    local left = Instance.new("Frame", window)
    left.Size = UDim2.new(0,160,1,-40)
    left.Position = UDim2.new(0,0,0,40)
    left.BackgroundTransparency = 1

    local content = Instance.new("Frame", window)
    content.Size = UDim2.new(1,-160,1,-40)
    content.Position = UDim2.new(0,160,0,40)
    content.BackgroundTransparency = 1

    local tabs = {}
    local screens = {}

    local function makeTab(name, order)
        local btn = Instance.new("TextButton", left)
        btn.Size = UDim2.new(1,-10,0,36)
        btn.Position = UDim2.new(0,5,0,5 + (order-1)*(36+10))
        btn.BackgroundColor3 = Color3.fromRGB(34,34,36)
        btn.Text = name
        btn.TextColor3 = Color3.fromRGB(220,220,220)
        btn.Font = Enum.Font.Gotham
        btn.TextSize = 14
        Instance.new("UICorner", btn)

        local scr = Instance.new("Frame", content)
        scr.Size = UDim2.new(1,-12,1,-12)
        scr.Position = UDim2.new(0,6,0,6)
        scr.BackgroundTransparency = 1
        scr.Visible = false

        screens[name] = scr

        btn.MouseButton1Click:Connect(function()
            for _,s in pairs(screens) do s.Visible=false end
            scr.Visible = true
            -- if teleport tab opened, refresh players immediately
            if name == "Teleport" and refreshTeleportPlayers then
                refreshTeleportPlayers()
            end
            if name == "Teleport-etc" and refreshTeleportEtc then
                refreshTeleportEtc()
            end
        end)
    end

    makeTab("Spawner",1)
    makeTab("Player",2)
    makeTab("Teleport",3)
    makeTab("Teleport-etc",4)
    makeTab("Settings",5)

    screens["Spawner"].Visible = true

    -- Settings screen content (small theme/config system)
    local settingsScreen = screens["Settings"]
    local function applyTheme(name)
        if name == "dark" then
            window.BackgroundColor3 = Color3.fromRGB(28,28,30)
            header.BackgroundColor3 = Color3.fromRGB(20,20,20)
        elseif name == "light" then
            window.BackgroundColor3 = Color3.fromRGB(240,240,240)
            header.BackgroundColor3 = Color3.fromRGB(220,220,220)
        elseif name == "purple" then
            window.BackgroundColor3 = Color3.fromRGB(60,20,80)
            header.BackgroundColor3 = Color3.fromRGB(40,10,60)
        end
        -- store current theme as attribute
        pcall(function() LocalPlayer:SetAttribute("NTD_Theme", name) end)
    end

    local themeLabel = Instance.new("TextLabel", settingsScreen)
    themeLabel.Size = UDim2.new(1,-20,0,20)
    themeLabel.Position = UDim2.new(0,10,0,10)
    themeLabel.BackgroundTransparency = 1
    themeLabel.Text = "Theme"
    themeLabel.Font = Enum.Font.Gotham
    themeLabel.TextColor3 = Color3.fromRGB(220,220,220)

    local btnDark = Instance.new("TextButton", settingsScreen)
    btnDark.Size = UDim2.new(0,100,0,28)
    btnDark.Position = UDim2.new(0,10,0,40)
    btnDark.Text = "Dark"
    Instance.new("UICorner", btnDark)
    btnDark.MouseButton1Click:Connect(function() applyTheme("dark") end)

    local btnLight = Instance.new("TextButton", settingsScreen)
    btnLight.Size = UDim2.new(0,100,0,28)
    btnLight.Position = UDim2.new(0,120,0,40)
    btnLight.Text = "Light"
    Instance.new("UICorner", btnLight)
    btnLight.MouseButton1Click:Connect(function() applyTheme("light") end)

    local btnPurple = Instance.new("TextButton", settingsScreen)
    btnPurple.Size = UDim2.new(0,100,0,28)
    btnPurple.Position = UDim2.new(0,230,0,40)
    btnPurple.Text = "Purple"
    Instance.new("UICorner", btnPurple)
    btnPurple.MouseButton1Click:Connect(function() applyTheme("purple") end)

    -- Save/Load config
    local saveBtn = Instance.new("TextButton", settingsScreen)
    saveBtn.Size = UDim2.new(0,100,0,28)
    saveBtn.Position = UDim2.new(0,10,0,80)
    saveBtn.Text = "Save Config"
    Instance.new("UICorner", saveBtn)
    saveBtn.MouseButton1Click:Connect(function()
        local cfg = {
            theme = LocalPlayer:GetAttribute("NTD_Theme") or "dark",
            walk = desiredWalk,
            jump = desiredJump,
            flyMode = flyMode,
        }
        local json = HttpService:JSONEncode(cfg)
        pcall(function() LocalPlayer:SetAttribute("NTD_Config", json) end)
        feedback.Text = "Config saved"
    end)

    local loadBtn = Instance.new("TextButton", settingsScreen)
    loadBtn.Size = UDim2.new(0,100,0,28)
    loadBtn.Position = UDim2.new(0,120,0,80)
    loadBtn.Text = "Load Config"
    Instance.new("UICorner", loadBtn)
    loadBtn.MouseButton1Click:Connect(function()
        local json = LocalPlayer:GetAttribute("NTD_Config")
        if json then
            local ok, cfg = pcall(function() return HttpService:JSONDecode(json) end)
            if ok and type(cfg) == "table" then
                if cfg.theme then applyTheme(cfg.theme) end
                if cfg.walk then desiredWalk = cfg.walk end
                if cfg.jump then desiredJump = cfg.jump end
                if cfg.flyMode then flyMode = cfg.flyMode; flyModeBtn.Text = "Fly Mode: "..flyMode end
                feedback.Text = "Config loaded"
            else
                feedback.Text = "Invalid config"
            end
        else
            feedback.Text = "No config saved"
        end
    end)

    -- Smooth tweened Drag
local dragging = false
local dragStart = Vector2.new()
local startPos = UDim2.new()

header.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = window.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

header.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        local dragInput = input
        dragInput.Changed:Connect(function()
            if dragging then
                local delta = dragInput.Position - dragStart
                window.Position = startPos + UDim2.new(0, delta.X, 0, delta.Y)
            end
        end)
    end
end)


    -- On mouse movement, tween the window to a target position near cursor (smoothed)
    local function tweenToPosition(targetPos)
        -- create UDim2 from target offset (center window at mouse)
        local targetUDim = UDim2.new(0, targetPos.X - window.AbsoluteSize.X/2, 0, targetPos.Y - window.AbsoluteSize.Y/2)
        -- stop previous tween by pausing it (safe) if exists
        if currentTween and currentTween.PlaybackState == Enum.PlaybackState.Playing then
            pcall(function() currentTween:Cancel() end) -- :Cancel might not exist on all builds, pcall to be safe
        end
        currentTween = tween(window, {Position = targetUDim}, 0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    end

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            -- use input.Position which is screen coordinates
            local mousePos = input.Position
            tweenToPosition(Vector2.new(mousePos.X, mousePos.Y))
        end
    end)

    -- --- SPAWNER TAB ---
    local spawnerTab = screens["Spawner"]
    local blockRemotes = {"SpawnDiamondBlock","SpawnGalaxyBlock","SpawnLuckyBlock","SpawnRainbowBlock","SpawnSuperBlock"}

    -- Info label for loop spawn
    local infoLabel = Instance.new("TextLabel", spawnerTab)
    infoLabel.Size = UDim2.new(1,-20,0,28)
    infoLabel.Position = UDim2.new(0,10,0,10)
    infoLabel.BackgroundTransparency = 1
    infoLabel.Text = "Lucky Block spawner. Use 'Loop Lucky (10s)' to spawn repeatedly for 10s."
    infoLabel.TextWrapped = true
    infoLabel.Font = Enum.Font.Gotham
    infoLabel.TextSize = 12
    infoLabel.TextColor3 = Color3.fromRGB(200,200,200)

    for i, remoteName in ipairs(blockRemotes) do
        local spawnBtn = Instance.new("TextButton", spawnerTab)
        spawnBtn.Size = UDim2.new(0,160,0,32)
        spawnBtn.Position = UDim2.new(0,10,0,40 + (i-1)*42)
        spawnBtn.BackgroundColor3 = Color3.fromRGB(70,130,240)
        spawnBtn.TextColor3 = Color3.fromRGB(255,255,255)
        spawnBtn.Text = remoteName:gsub("Spawn","")
        Instance.new("UICorner", spawnBtn)

        local debounce = false
        spawnBtn.MouseButton1Click:Connect(function()
            if debounce then return end
            debounce = true
            local originalText = spawnBtn.Text
            spawnBtn.Text = "Spawning..."
            local remote = ReplicatedStorage:FindFirstChild(remoteName)
            if remote then
                if remote:IsA("RemoteEvent") then
                    pcall(function() remote:FireServer() end)
                elseif remote:IsA("RemoteFunction") then
                    pcall(function() remote:InvokeServer() end)
                end
            else
                spawnBtn.Text = "Remote not found"
                wait(1)
            end
            spawnBtn.Text = originalText
            wait(0.5)
            debounce = false
        end)
    end

    -- Loop spawn Lucky Blocks for 10s button (fires SpawnLuckyBlock repeatedly)
    local loopBtn = Instance.new("TextButton", spawnerTab)
    loopBtn.Size = UDim2.new(0,200,0,32)
    loopBtn.Position = UDim2.new(0,10,0,40 + (#blockRemotes)*42)
    loopBtn.BackgroundColor3 = Color3.fromRGB(180,90,220)
    loopBtn.TextColor3 = Color3.fromRGB(255,255,255)
    loopBtn.Text = "Loop Lucky (10s)"
    Instance.new("UICorner", loopBtn)

    local looping = false
    loopBtn.MouseButton1Click:Connect(function()
        if looping then return end
        looping = true
        local originalText = loopBtn.Text
        loopBtn.Text = "Looping..."
        local remote = ReplicatedStorage:FindFirstChild("SpawnLuckyBlock")
        if not remote then
            loopBtn.Text = "Remote missing"
            wait(1.2)
            loopBtn.Text = originalText
            looping = false
            return
        end

        local stopTime = tick() + 10 -- 10 seconds from now
        while tick() < stopTime do
            -- call remote for yourself
            if remote:IsA("RemoteEvent") then
                pcall(function() remote:FireServer() end)
            elseif remote:IsA("RemoteFunction") then
                pcall(function() remote:InvokeServer() end)
            end
            wait() -- approx spawn every 0.45s (adjustable)
        end

        loopBtn.Text = "Done (10s)"
        wait(0.9)
        loopBtn.Text = originalText
        looping = false
    end)

    -- --- PLAYER TAB ---
    local playerTab = screens["Player"]
    local function createSlider(parent,labelText,min,max,default,callback,yOffset)
        local container = Instance.new("Frame", parent)
        container.Size = UDim2.new(1,-20,0,50)
        container.Position = UDim2.new(0,10,0,yOffset)
        container.BackgroundTransparency = 1

        local label = Instance.new("TextLabel", container)
        label.Size = UDim2.new(1,0,0,20)
        label.Position = UDim2.new(0,0,0,0)
        label.BackgroundTransparency = 1
        label.Text = labelText.." ("..default..")"
        label.Font = Enum.Font.Gotham
        label.TextSize = 14
        label.TextColor3 = Color3.fromRGB(220,220,220)
        label.TextXAlignment = Enum.TextXAlignment.Left

        local slider = Instance.new("Frame", container)
        slider.Size = UDim2.new(1,0,0,20)
        slider.Position = UDim2.new(0,0,0,25)
        slider.BackgroundColor3 = Color3.fromRGB(70,70,70)
        Instance.new("UICorner", slider)

        local fill = Instance.new("Frame", slider)
        fill.Size = UDim2.new((default-min)/(max-min),0,1,0)
        fill.BackgroundColor3 = Color3.fromRGB(70,130,240)
        Instance.new("UICorner", fill)

        local hit = Instance.new("TextButton", slider)
        hit.Size = UDim2.new(1,0,1,0)
        hit.BackgroundTransparency = 1
        hit.Text = ""
        hit.AutoButtonColor = false

        local draggingSlider = false
        local function setFromPosition(absX)
            local rel = math.clamp(absX - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X)
            local val = math.floor((rel/slider.AbsoluteSize.X)*(max-min) + min)
            val = math.clamp(val, min, max)
            fill.Size = UDim2.new((val-min)/(max-min),0,1,0)
            label.Text = labelText.." ("..val..")"
            pcall(callback, val)
        end

        hit.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                draggingSlider = true
                setFromPosition(input.Position.X)
            end
        end)
        hit.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                draggingSlider = false
            end
        end)
        table.insert(connections, UserInputService.InputChanged:Connect(function(input)
            if draggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then
                setFromPosition(input.Position.X)
            end
        end))

        -- ensure proper initial setting after layout
        slider:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
            setFromPosition(slider.AbsolutePosition.X + fill.AbsoluteSize.X)
        end)
    end

    local yOffset = 10

    createSlider(playerTab,"WalkSpeed",16,200,_G.CustomKeyState.desiredWalk,function(val)
        _G.CustomKeyState.desiredWalk = val
        LocalPlayer:SetAttribute("NTD_WalkSpeed", val) -- persist value
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = val
        end
    end,yOffset); yOffset = yOffset + 60

    createSlider(playerTab,"JumpPower",50,300,_G.CustomKeyState.desiredJump,function(val)
        _G.CustomKeyState.desiredJump = val
        LocalPlayer:SetAttribute("NTD_JumpPower", val) -- persist value
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            LocalPlayer.Character:FindFirstChildOfClass("Humanoid").JumpPower = val
        end
    end,yOffset); yOffset = yOffset + 60

    createSlider(playerTab,"MaxHealth",100,1000,100,function(val)
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            hum.MaxHealth = val
            hum.Health = val
        end
    end,yOffset); yOffset = yOffset + 60

    -- persist desired player values so equipment doesn't reset them
    table.insert(connections, RunService.Heartbeat:Connect(function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if hum then
                if hum.WalkSpeed ~= _G.CustomKeyState.desiredWalk then 
                    hum.WalkSpeed = _G.CustomKeyState.desiredWalk
                end
                if hum.JumpPower ~= _G.CustomKeyState.desiredJump then 
                    hum.JumpPower = _G.CustomKeyState.desiredJump
                end
            end
        end
    end))

    local flySpeed = 100
    createSlider(playerTab,"Fly Speed",50,300,100,function(val) flySpeed = val end,yOffset); yOffset = yOffset + 60

    -- Advanced Fly (robust, single set of connections)
    local flying = false
    local flyToggle = Instance.new("TextButton", playerTab)
    flyToggle.Size = UDim2.new(0,160,0,32)
    flyToggle.Position = UDim2.new(0,10,0,yOffset)
    flyToggle.BackgroundColor3 = Color3.fromRGB(70,130,240)
    flyToggle.TextColor3 = Color3.fromRGB(255,255,255)
    flyToggle.Text = "Toggle Fly"
    Instance.new("UICorner", flyToggle)

    local flyBV, flyBG
    local flyRenderConn, flyBeginConn, flyEndConn, flyCharConn
    local inputKeys = {W=false,A=false,S=false,D=false,Up=false,Down=false}
    local flyMode = "Velocity" -- or "CFrame"
    local flyModeBtn = Instance.new("TextButton", playerTab)
    flyModeBtn.Size = UDim2.new(0,160,0,28)
    flyModeBtn.Position = UDim2.new(0,180,0,yOffset - 28)
    flyModeBtn.BackgroundColor3 = Color3.fromRGB(100,100,120)
    flyModeBtn.TextColor3 = Color3.fromRGB(255,255,255)
    flyModeBtn.Text = "Fly Mode: Velocity"
    flyModeBtn.Font = Enum.Font.Gotham
    flyModeBtn.TextSize = 12
    Instance.new("UICorner", flyModeBtn)
    flyModeBtn.MouseButton1Click:Connect(function()
        flyMode = (flyMode == "Velocity") and "CFrame" or "Velocity"
        flyModeBtn.Text = "Fly Mode: "..flyMode
    end)
    local function startFly()
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        if hrp:FindFirstChild("FlyVelocity") then hrp.FlyVelocity:Destroy() end
        if hrp:FindFirstChild("FlyGyro") then hrp.FlyGyro:Destroy() end

        flyBV = Instance.new("BodyVelocity")
        flyBV.Name = "FlyVelocity"
        flyBV.MaxForce = Vector3.new(1e5,1e5,1e5)
        flyBV.Velocity = Vector3.new(0,0,0)
        flyBV.P = 1250
        flyBV.Parent = hrp

        flyBG = Instance.new("BodyGyro")
        flyBG.Name = "FlyGyro"
        flyBG.MaxTorque = Vector3.new(1e5,1e5,1e5)
        flyBG.P = 1250
        flyBG.CFrame = hrp.CFrame
        flyBG.Parent = hrp

        local cam = workspace.CurrentCamera
        local accel = 0.35

        flyRenderConn = RunService.RenderStepped:Connect(function()
            if not flying or not hrp or not flyBV or not flyBG then return end
            local dir = Vector3.new()
            if inputKeys.W then dir = dir + cam.CFrame.LookVector end
            if inputKeys.S then dir = dir - cam.CFrame.LookVector end
            if inputKeys.A then dir = dir - cam.CFrame.RightVector end
            if inputKeys.D then dir = dir + cam.CFrame.RightVector end
            if inputKeys.Up then dir = dir + Vector3.new(0,1,0) end
            if inputKeys.Down then dir = dir - Vector3.new(0,1,0) end

            local target = (dir.Magnitude > 0) and dir.Unit * flySpeed or Vector3.new(0,0,0)
            if flyMode == "Velocity" then
                flyBV.Velocity = flyBV.Velocity:Lerp(target, accel)
            else
                -- CFrame mode: set CFrame directly for smoother camera-aligned movement
                local moveVec = target * (1/60) -- small step per frame
                hrp.CFrame = hrp.CFrame + moveVec
            end
            flyBG.CFrame = hrp.CFrame:Lerp(CFrame.new(hrp.Position, hrp.Position + cam.CFrame.LookVector), accel)
        end)

        flyBeginConn = UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end
            local k = input.KeyCode
            if k == Enum.KeyCode.W then inputKeys.W = true end
            if k == Enum.KeyCode.S then inputKeys.S = true end
            if k == Enum.KeyCode.A then inputKeys.A = true end
            if k == Enum.KeyCode.D then inputKeys.D = true end
            if k == Enum.KeyCode.Space then inputKeys.Up = true end
            if k == Enum.KeyCode.LeftShift then inputKeys.Down = true end
        end)
        flyEndConn = UserInputService.InputEnded:Connect(function(input, processed)
            if processed then return end
            local k = input.KeyCode
            if k == Enum.KeyCode.W then inputKeys.W = false end
            if k == Enum.KeyCode.S then inputKeys.S = false end
            if k == Enum.KeyCode.A then inputKeys.A = false end
            if k == Enum.KeyCode.D then inputKeys.D = false end
            if k == Enum.KeyCode.Space then inputKeys.Up = false end
            if k == Enum.KeyCode.LeftShift then inputKeys.Down = false end
        end)

        flyCharConn = LocalPlayer.CharacterAdded:Connect(function()
            -- cleanup if character respawns
            flying = false
            if flyRenderConn then flyRenderConn:Disconnect(); flyRenderConn=nil end
            if flyBeginConn then flyBeginConn:Disconnect(); flyBeginConn=nil end
            if flyEndConn then flyEndConn:Disconnect(); flyEndConn=nil end
            if flyCharConn then flyCharConn:Disconnect(); flyCharConn=nil end
            if flyBV and flyBV.Parent then flyBV:Destroy(); flyBV = nil end
            if flyBG and flyBG.Parent then flyBG:Destroy(); flyBG = nil end
        end)
    end

    local function stopFly()
        flying = false
        if flyRenderConn then flyRenderConn:Disconnect(); flyRenderConn=nil end
        if flyBeginConn then flyBeginConn:Disconnect(); flyBeginConn=nil end
        if flyEndConn then flyEndConn:Disconnect(); flyEndConn=nil end
        if flyCharConn then flyCharConn:Disconnect(); flyCharConn=nil end
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            if hrp:FindFirstChild("FlyVelocity") then hrp.FlyVelocity:Destroy() end
            if hrp:FindFirstChild("FlyGyro") then hrp.FlyGyro:Destroy() end
        end
    end

    flyToggle.MouseButton1Click:Connect(function()
        flying = not flying
        flyToggle.Text = flying and "Fly: ON" or "Fly: OFF"
        if flying then
            startFly()
        else
            stopFly()
        end
    end)

    -- --- TELEPORT TAB ---
    local teleportTab = screens["Teleport"]
    local playerButtons = {}

    function refreshTeleportPlayers()
        -- destroy existing player buttons
        for _, btn in ipairs(playerButtons) do
            if btn and btn.Parent then btn:Destroy() end
        end
        playerButtons = {}
        local y = 10
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local btn = Instance.new("TextButton", teleportTab)
                btn.Size = UDim2.new(0,180,0,32)
                btn.Position = UDim2.new(0,10,0,y)
                btn.BackgroundColor3 = Color3.fromRGB(70,130,240)
                btn.TextColor3 = Color3.fromRGB(255,255,255)
                btn.Text = "Teleport to "..plr.Name
                Instance.new("UICorner", btn)
                btn.MouseButton1Click:Connect(function()
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character.HumanoidRootPart.CFrame = plr.Character.HumanoidRootPart.CFrame + Vector3.new(0,5,0)
                    end
                end)
                table.insert(playerButtons, btn)
                y = y + 42
            end
        end
    end

    -- Auto-update on join/leave
    table.insert(connections, Players.PlayerAdded:Connect(refreshTeleportPlayers))
    table.insert(connections, Players.PlayerRemoving:Connect(refreshTeleportPlayers))

    -- --- TELEPORT-ETC TAB ---
    local teleportEtcTab = screens["Teleport-etc"]

    local function getModelCenter(model)
        if model.PrimaryPart then return model.PrimaryPart.Position end
        local sum = Vector3.new(0,0,0)
        local count = 0
        for _,c in pairs(model:GetDescendants()) do
            if c:IsA("BasePart") then
                sum = sum + c.Position
                count = count + 1
            end
        end
        if count > 0 then return sum / count end
        return nil
    end

    function refreshTeleportEtc()
        -- clear previous buttons
        for _, obj in pairs(teleportEtcTab:GetChildren()) do
            if obj:IsA("TextButton") then obj:Destroy() end
        end
        local y = 10
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            -- Detect current Spawn1..Spawn8
            local currentSpawn
            for i=1,8 do
                local spawnModel = Workspace:FindFirstChild("Spawn"..i)
                if spawnModel then
                    local pos = getModelCenter(spawnModel)
                    local size = spawnModel:GetExtentsSize()
                    if pos then
                        local maxRange = math.max(size.X, size.Z)/2 + 8
                        if (hrp.Position - pos).Magnitude <= maxRange then
                            currentSpawn = spawnModel
                            break
                        end
                    end
                end
            end
            if currentSpawn and currentSpawn.PrimaryPart then
                local btn = Instance.new("TextButton", teleportEtcTab)
                btn.Size = UDim2.new(0,180,0,32)
                btn.Position = UDim2.new(0,10,0,y)
                btn.BackgroundColor3 = Color3.fromRGB(120,70,200)
                btn.TextColor3 = Color3.fromRGB(255,255,255)
                btn.Text = "Teleport to "..currentSpawn.Name
                Instance.new("UICorner", btn)
                btn.MouseButton1Click:Connect(function()
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character.HumanoidRootPart.CFrame = currentSpawn.PrimaryPart.CFrame + Vector3.new(0,5,0)
                    end
                end)
                y = y + 42
            end
        end

        -- Teleport to BlockGivers (including Rainbow1/Rainbow2 etc)
        local giversFolder = Workspace:FindFirstChild("CenterBlocks") and Workspace.CenterBlocks:FindFirstChild("Givers")
        if giversFolder then
            for _, giver in pairs(giversFolder:GetChildren()) do
                if giver:IsA("Model") then
                    -- try to find a primary part or compute center
                    local pos = getModelCenter(giver)
                    if pos then
                        local btn = Instance.new("TextButton", teleportEtcTab)
                        btn.Size = UDim2.new(0,180,0,32)
                        btn.Position = UDim2.new(0,10,0,y)
                        btn.BackgroundColor3 = Color3.fromRGB(70,130,240)
                        btn.TextColor3 = Color3.fromRGB(255,255,255)
                        btn.Text = "Teleport to "..giver.Name
                        Instance.new("UICorner", btn)
                        btn.MouseButton1Click:Connect(function()
                            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                if giver.PrimaryPart then
                                    LocalPlayer.Character.HumanoidRootPart.CFrame = giver.PrimaryPart.CFrame + Vector3.new(0,5,0)
                                else
                                    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(pos) + Vector3.new(0,5,0)
                                end
                            end
                        end)
                        y = y + 42
                    end
                end
            end
        end
    end

    -- initial refresh calls
    refreshTeleportPlayers()
    refreshTeleportEtc()

    -- ensure Teleport tab updates when opened (handler in makeTab above triggers refresh)
    -- refresh on players join/remove already connected

    -- when GUI destroyed, clean up connections (not strictly necessary here, but good practice)
    table.insert(connections, screenGui.AncestryChanged:Connect(function(_, parent)
        if not parent then
            for _, c in ipairs(connections) do
                if c and c.Disconnect then pcall(function() c:Disconnect() end) end
            end
        end
    end))
end

-- --- BUTTONS ---
submit.MouseButton1Click:Connect(function()
    local val = inputBox.Text or ""
    if table.find(ALLOWED_KEYS,val) then
        unlock()
    else
        feedback.Text = "Invalid key!"
    end
end)

copyBtn.MouseButton1Click:Connect(function()
    local success = pcall(function()
        setclipboard("https://discord.gg/jGPXgGp6")
    end)
    feedback.Text = success and "Discord link copied!" or "Failed to copy link."
end)

    -- Mobile support: toggle button + touch drag handlers
    local mobileToggle = Instance.new("TextButton", screenGui)
    mobileToggle.Name = "MobileToggle"
    mobileToggle.Size = UDim2.new(0,48,0,48)
    mobileToggle.Position = UDim2.new(1,-60,1,-60)
    mobileToggle.AnchorPoint = Vector2.new(0,0)
    mobileToggle.BackgroundColor3 = Color3.fromRGB(90,90,100)
    mobileToggle.TextColor3 = Color3.fromRGB(255,255,255)
    mobileToggle.Text = "M:OFF"
    mobileToggle.Font = Enum.Font.GothamBold
    mobileToggle.TextSize = 14
    Instance.new("UICorner", mobileToggle)

    local mobileMode = false

    -- Helper to apply mobile-friendly sizing when enabled
    local function applyMobileMode(enabled)
        mobileMode = enabled
        mobileToggle.Text = enabled and "M:ON" or "M:OFF"
        -- enlarge tab buttons for easier touch
        for _, child in pairs(left:GetChildren()) do
            if child:IsA("TextButton") then
                if enabled then
                    child.Size = UDim2.new(1,-10,0,48)
                else
                    child.Size = UDim2.new(1,-10,0,36)
                end
            end
        end
        -- increase header height slightly for touch targets
        header.Size = enabled and UDim2.new(1,0,0,56) or UDim2.new(1,0,0,40)
    end

    mobileToggle.MouseButton1Click:Connect(function()
        applyMobileMode(not mobileMode)
    end)

    -- Touch dragging support (separate and additive to existing mouse handlers)
    -- Start drag on touch begin inside header
    header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = window.Position
            -- end drag when this touch ends
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    -- Move window on touch movement while dragging
    table.insert(connections, UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch and dragging then
            local delta = input.Position - dragStart
            window.Position = startPos + UDim2.new(0, delta.X, 0, delta.Y)
        end
    end))
